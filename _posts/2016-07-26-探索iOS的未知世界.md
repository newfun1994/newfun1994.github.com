---
layout: post
title:	"探索iOS的未知世界"
data:	2016-07-26 8:22:43 +0800
categories:	iOS
---


## iOS

知识点来自Effective Objective-C 2.0

1. 消息结构(messaging structure)

   ​	特点:消息结构语言在运行时所执行的代码有运行环境来决定，在运行是才会去查找所要执行的方法。其过程叫做动态绑定。

2. 动态绑定(dynamic binding)

   > 编译器将代码`[obj makeText];`转化为`objc_msgSend(obj, @selector (makeText));`，在`objc_msgSend`函数中。首先通过obj的isa指针找到obj对应的class。在Class中先去cache中 通过SEL查找对应函数method，若 cache中未找到。再去methodList中查找，若methodlist中未找到，则取superClass中查找。若能找到，则将method加 入到cache中，以方便下次查找，并通过method中的函数指针跳转到对应的函数中去执行。

   [摘自---Objective-C总Runtime的那点事儿（一）消息机制](http://www.cocoachina.com/ios/20141018/9960.html)

   [参考---Objective-C消息机制的原理](http://dangpu.sinaapp.com/?p=119)

3. C语言内存模型(memory model)

   ​	1、程序代码区:存放函数体的二进制代码。

   ​	2、全局区数据区：全局数据区划分为三个区域。全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。常量数据存放在另一个区域里。这些数据在程序结束后由系统释放。我们所说的BSS段(bss segment)通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。

   ​	3、栈区:由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

   ​	4、堆区:一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。`注意`它与数据结构中的堆是两回事，分配方式倒是类似于链表。

   ​	5、命令行参数区:存放命令行参数和环境变量的值，如通过main()函数传递的值。

   [参考---C语言内存模型](http://c.biancheng.net/cpp/html/2857.html)

   [参考---Introduction to C Memory Model](http://www.cs.cornell.edu/courses/cs2022/2011sp/lectures/lect06.pdf)

4. 引用计数器(reference count)

   | Method      | Behavior                                 |
   | :---------- | :--------------------------------------- |
   | alloc       | Create an object and claim ownership of it. |
   | retain      | Claim ownership of an existing object.   |
   | copy        | Copy an object and claim ownership of it. |
   | release     | Relinquish ownership of an object and destroy it immediately. |
   | autorelease | Relinquish ownership of an object but defer its destruction. |

   ![](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Art/memory_management_2x.png)

   [表格摘自---Memory Management](http://rypress.com/tutorials/objective-c/memory-management)

   [图片摘自---About Memory Management](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html)

   [参考---Understanding reference counting with Cocoa and Objective-C](http://stackoverflow.com/questions/6578/understanding-reference-counting-with-cocoa-and-objective-c)

5. 堆空间与栈空间

   ​	栈:由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。

   ​	堆: 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定。所以调用这些对象的速度要相对来得低一些。	

   [参考---Differences between Stack and Heap](http://net-informations.com/faq/net/stack-heap.htm)

6. @class向前声明(foreard declaring)

   尽量少在头文件中引用其他头文件

   ```objective-c
   //ClassA.h
   #import <Foundation/Foundation.h>
   #import ClassB.h;	//不推荐

   @class ClassB;		//推荐

   @interface ClassA: NSObject
   @proparty (nonatomic, strong) ClassB *classB;
   ```

   原因: 

   - 不够优雅
   - 会增加编译时间
   - 有可能会导致循环引用
   - 增加耦合度

   [参考---class-vs-import](http://stackoverflow.com/questions/322597/class-vs-import)

   [参考---@class #import辨析 #include](http://blog.csdn.net/chengwuli125/article/details/9705315)

7. `#import`与`#include`区别

   ​		`#import` 是 `#include` 的改善版，使用 `#import` 可以确保文件只被引用一次，`#import`避免重复引用。

   ​	`Tips`：#import<>引用的是库，#import""引用的是文件

   [参考---#include、#import和@class区别](http://www.saitjr.com/ios/oc-include-import-class-difference.html)

8. 协议(protocol)与委托协议(delegtate)

   ```objective-c
   @protocol chinaPeopleProtocol <NSObject>
   @require
   - (void)getEducation;		//义务

   @option
   - (void)giveSeatToLRBCY;	//道德
   @end
   ```

   [参考---Working with Protocols](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithProtocols/WorkingwithProtocols.html)

   [参考---iOS开发中怎样精辟易懂的解释 Delegate protocol interface这些概念？](http://www.zhihu.com/question/33498315?sort=created)

9. class-continuation分类(class-continuation category)

   ​	class-continuation分类又称延展、又叫class extension等

   ​	Extension是Category的一个特例，可以为某个类扩充一些私有成员变量和方法。

   [参考---Objective-C 实现类中Continuation Category或Class Extension](http://www.cnblogs.com/tuncaysanli/archive/2012/10/17/2728013.html)

   [参考---Difference between Category and Class Extension?](http://stackoverflow.com/questions/3499704/difference-between-category-and-class-extension)

10. 字面量(糖衣语法、语法糖: syntactic sugar)

      NSString *str = @"123";

      NSNumber *num = @123;

      NSArray *ary = @[@"0",@"1",@"2"];     ary[1] = @"1";(取下标)

      NSDictionary *dic =  @{@"1":"one",@"2":@"two"};    dic[@"1"]=@"one";

      优点：简洁、安全

      缺点：局限性、创建的对象必须属于Foundation框架

   [科普---语法糖](http://baike.baidu.com/link?url=gLkqwQE87EusrKvuH9XIFQcr1fDT161-KYWgw4E670AKeMzcK5ZpiORoAtBiRIup75TE8i9nbbwU0Wu3Ml6MR_)

   [参考---iOS中的字面量语法](http://www.jianshu.com/p/e89bd39e4849)

1.  @property

       @property = ivar + getter + setter;

       属性可以拥有的特质分为四类

-  原子性(atomic/nonatomic)

-  读/写权限(readwrite/readonly)
   - 内存管理语义(assign/retain/strong/weak/unsafe_unretained/copy）

     [iOS NSString，NSArray，NSDictionary的Copy属性使用](http://www.jianshu.com/p/4acb81deed28)

   - 方法名(getter=<name>/setter=<name>)

   [参考---Objective-C中的@property](http://www.devtalking.com/articles/you-should-to-know-property/)

   [参考---Properties Encapsulate an Object’s Values](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html)

   [参考---@property属性关键字详解](http://www.wugaojun.com/blog/2015/07/25/at-propertyshu-xing-guan-jian-zi-xiang-jie/)

1.  @synthesize

    > `@synthesize` 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。

    [摘自---@synthesize和@dynamic分别有什么作用](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#11-synthesize%E5%92%8Cdynamic%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8)

    `@synthesize`这个关键词现在已经出现机会不多了，在网上搜索大多是12年13年时候的帖子了，在此之前我一直没搞懂@property声明变量后，在实现文件里面使用该变量为啥前面要加`_xxx`。

    因为Xcode4.4之前@property不会自动生成getter，setter方法，要通过`@synthesize xxx = _xxx`自动实现。久而久之`_xxx`就变成了一种习惯，当Xcode变强大后可以自动生成getter，setter方法，这种`_xxx`的习惯了也就被保留下来了。

    那现在是不是`@synthesize`就没用了

    如果你想使用`xxx`来代替`_xxx`，那么`@synthesize xxx`

    如果你想用`aaa`来代替`_xxx`，那么`@synthesize xxx = aaa`

2.  @dynamic

    > `@dynamic` 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。

    [摘自---@synthesize和@dynamic分别有什么作用](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#11-synthesize%E5%92%8Cdynamic%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8)

    如果你`@dynamic XXX`了，并没用手动实现getter，setter方法，那么意味着你`_xxx`,`self.xxx`,`[self xxx]`,`[self setXxx]`不能用了，
